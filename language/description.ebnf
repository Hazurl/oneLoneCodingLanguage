(*
    /!\ This file use a variant of the ebnf's syntax
    
    Concatenation doesn't use `,`, but is implicit
    Rule's identifier can't have space in them, but will use underscore
    `a \ b` denote all string parsed with a but not b
    It is use only for simple case like reserved_identifier where the operation is trivial
*)
(*
    Basic
*)

uppercase_letters := ? A-Z ?;
lowercase_letters := ? a-z ?;
letters := uppercase-letters | lowercase-letters;
digits := ? 0-9 ?;

reserved_indentifier := "type" | "alias";
type_identifier := uppercase_letters {letters | digits | "_"};
var_identifier := lowercase_letters {letters | digits | "_"} \ reserved_indentifier; 

operator_list := "+" | "*" | "/" | "-" | "=" | "<" | ">" | "!" | "." | "|" | "^" | "$" | "%" | ":" | "~" | "#" | "&";
operator := operator_list {operator_list};
reserved_operator := ;
user_operator := operator \ reserved_operator; 

(*
    Types
*)

(*
    simple_type is either a single identifier or multiple one between parenthesis
    ex:
        Int
        (Maybe Int)
        (A -> B)
*)

simple_type := 
    type_identifier
|   '(' complex_type ')'
;

(*
    complex_type doesn't have the restriction to be in parenthesis
    ex: 
        Bool
        Maybe (Maybe Int)
        Either (Int -> Bool) (Float -> Bool)
        Int -> Maybe Int -> Int
        F A -> (A -> F B) -> F B
*)

complex_type :=
    type_parametric {simple_type} ["->" type]
|   "(" type_parametric {simple_type} "->" type ")" ["->" type]
;

(*
    ex:
        type Maybe A = Nothing | (Just A)
        type Vec3 T = T T T
        alias Vec3f = Vec3 Float
        type ComposeFunction A B C = ((B -> C) -> (A -> C) -> A -> C)
*)

alias_type_declaration :=
    simple_type "=" simple_type {simple_type} {"|" simple_type {simple_type}}
;

type_declaration :=
    "type" alias_type_declaration
;

alias_declaration :=
    "alias" alias_type_declaration
;

