(*
    /!\ This file use a variant of the ebnf's syntax
    
    Concatenation doesn't use `,`, but is implicit
    Rule's identifier can't have space in them, but will use underscore
    `a \ b` denote all string parsed with a but not b
    It is use only for simple case like reserved_identifier where the operation is trivial
*)
(*
    Basic
*)

uppercase_letters := ? A-Z ?;
lowercase_letters := ? a-z ?;
letters := uppercase-letters | lowercase-letters;
digits := ? 0-9 ?;

reserved_indentifier := "type" | "alias" | "lambda";
type_identifier := uppercase_letters {letters | digits | "_"};
var_identifier := lowercase_letters {letters | digits | "_"} \ reserved_indentifier; 

operator_list := "+" | "*" | "/" | "-" | "=" | "<" | ">" | "!" | "." | "|" | "^" | "$" | "%" | ":" | "~" | "#" | "&";
operator := operator_list {operator_list};
reserved_operator := ;
user_operator := operator \ reserved_operator; 

(*
    Types
*)

(*
    simple_type is either a single identifier or multiple one between parenthesis
    ex:
        Int
        (Maybe Int)
        (A -> B)
*)

simple_type := 
    type_identifier
|   '(' complex_type ')'
;

(*
    complex_type doesn't have the restriction to be in parenthesis
    ex: 
        Bool
        Maybe (Maybe Int)
        Either (Int -> Bool) (Float -> Bool)
        Int -> Maybe Int -> Int
        F A -> (A -> F B) -> F B
*)

complex_type :=
    type_parametric {simple_type} ["->" type]
|   "(" type_parametric {simple_type} "->" type ")" ["->" type]
;

(*
    ex:
        type Maybe A = Nothing | (Just A)
        type Vec3 T = T T T
        alias Vec3f = Vec3 Float
        type ComposeFunction A B C = ((B -> C) -> (A -> C) -> A -> C)
*)

alias_type_declaration :=
    simple_type "=" simple_type {simple_type} {"|" simple_type {simple_type}}
;

type_declaration :=
    "type" alias_type_declaration
;

alias_declaration :=
    "alias" alias_type_declaration
;

(*
    Value
    This denote parsable unit representating a construction of a value of a type
*)

(*
    ex:
        0
        12.
        123.456
        ""
        '.'
        "\"\""
        "blabla"
        lambda () {}
        lambda (x : Int, y : Int) -> Int { return x + y; }
        lambda () { return True; }
        Int (42)
        Maybe Int ( Just (42) )
        Vec2f (1, -1.2)
        Int -> Int ( lambda (a : Int) -> Int { return a + 1; } )
*)

value :=
    literals
|   complex_type ["(" [expr {"," expr}]")"]
;

literals :=
    number_literal
|   string_literal
|   lambda_literal
;

(*
    Add hex and binary form
*)
number_literal :=
    digits {digits} ["." {digits}]
;

string_literal :=
    '"' {? all ascii characters except "\" and '"' ? | "\" ? any valid escape character ?} '"'
|   "'" (? all ascii characters except "\" and "'" ? | "\" ? any valid escape character ?) "'"
;

lambda_literal :=
    "lambda" "(" {variable_declaration} ")" ["->" complex_type] "{" {statement} "}"
;

(*
    Expression
*)

expr :=
    value
;